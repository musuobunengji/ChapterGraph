import type { CoreState, ViewLink, ViewNode } from "./types";

declare const d3: any;

const BOOK_COLORS = ["#3b82f6", "#22c55e", "#f59e0b", "#ef4444", "#8b5cf6"];

function getBookRadius(node: ViewNode) {
    const count = node.chapterCount ?? 1;
    return 12 + Math.sqrt(Math.max(count, 1)) * 2.2;
}

function getNodeRadius(node: ViewNode) {
    return node.type === "book" ? getBookRadius(node) : 5.5;
}

export function findNodeAtPosition(state: CoreState, x: number, y: number) {
    for (let i = state.nodes.length - 1; i >= 0; i -= 1) {
        const n = state.nodes[i];
        if (n.x == null || n.y == null) continue;
        const r = getNodeRadius(n);
        const dx = x - n.x;
        const dy = y - n.y;
        if (dx * dx + dy * dy <= r * r) return n;
    }
    return null;
}

export function buildView(
    state: CoreState,
    previousNodes: ViewNode[],
): { nodes: ViewNode[]; links: ViewLink[] } {
    if (!state.graph) {
        return { nodes: [], links: [] };
    }

    // invariants:
    // - every link connects two visible nodes (checked via visibleChapterIds)
    // - book nodes never appear when expanded (expandedBooks gate)
    // - node.id is globally unique (book-... vs chapter-...)
    const books = state.graph.nodes.filter(n => n.type === "book");
    const chapters = state.graph.nodes.filter(n => n.type === "chapter");

    const chapterCountMap = new Map<string, number>();
    chapters.forEach(c => {
        chapterCountMap.set(
            c.book_id,
            (chapterCountMap.get(c.book_id) ?? 0) + 1,
        );
    });

    const bookColorMap = new Map<string, string>();
    books.forEach((b, i) => {
        bookColorMap.set(b.id, BOOK_COLORS[i % BOOK_COLORS.length]);
    });

    const prevPositions = new Map<
        string,
        { x?: number | null; y?: number | null; fx?: number | null; fy?: number | null }
    >();
    previousNodes.forEach(n => {
        if (n.x != null && n.y != null) {
            prevPositions.set(n.id, { x: n.x, y: n.y, fx: n.fx, fy: n.fy });
        }
    });

    const chapterCentroids = new Map<string, { x: number; y: number; count: number }>();
    previousNodes.forEach(n => {
        if (n.type !== "chapter" || n.x == null || n.y == null) return;
        const current = chapterCentroids.get(n.bookId) ?? { x: 0, y: 0, count: 0 };
        chapterCentroids.set(n.bookId, {
            x: current.x + n.x,
            y: current.y + n.y,
            count: current.count + 1,
        });
    });

    const nextNodes: ViewNode[] = [];
    const nextLinks: ViewLink[] = [];
    const visibleChapterIds = new Set<string>();

    books.forEach(book => {
        const color = bookColorMap.get(book.id)!;
        const bookKey = `book-${book.id}`;

        if (state.expandedBooks.has(book.id)) {
            const base = prevPositions.get(bookKey);
            const centroid = chapterCentroids.get(book.id);
            const bx =
                base?.x ??
                (centroid ? centroid.x / centroid.count : state.dimensions.width / 2);
            const by =
                base?.y ??
                (centroid ? centroid.y / centroid.count : state.dimensions.height / 2);

            const bookChapters = chapters.filter(c => c.book_id === book.id);
            bookChapters.forEach((c, i) => {
                const id = `chapter-${c.id}`;
                const prev = prevPositions.get(id);
                const angle = i * 0.55;
                const radius = 10 + i * 3.2;

                nextNodes.push({
                    id,
                    type: "chapter",
                    bookId: book.id,
                    label: c.title ? `${c.title}` : c.id,
                    chapterId: c.id,
                    color,
                    x: prev?.x ?? bx + Math.cos(angle) * radius,
                    y: prev?.y ?? by + Math.sin(angle) * radius,
                    fx: prev?.fx,
                    fy: prev?.fy,
                });
                visibleChapterIds.add(id);
            });
        } else {
            const prev = prevPositions.get(bookKey);
            nextNodes.push({
                id: bookKey,
                type: "book",
                bookId: book.id,
                label: book.id,
                color,
                chapterCount: chapterCountMap.get(book.id) ?? book.size,
                x: prev?.x,
                y: prev?.y,
                fx: prev?.fx,
                fy: prev?.fy,
            });
        }
    });

    state.graph.edges.forEach(e => {
        const s = `chapter-${e.source}`;
        const t = `chapter-${e.target}`;
        if (visibleChapterIds.has(s) && visibleChapterIds.has(t)) {
            nextLinks.push({ source: s, target: t, score: e.score });
        }
    });

    return { nodes: nextNodes, links: nextLinks };
}

export function rebuildGraph(state: CoreState, simulationRef: { current: any }) {
    if (!state.graph) return;

    const view = buildView(state, state.nodes);
    state.nodes = view.nodes;
    state.links = view.links;

    if (simulationRef.current) simulationRef.current.stop();
    simulationRef.current = d3
        .forceSimulation(state.nodes)
        .force(
            "link",
            d3.forceLink(state.links)
                .id((d: ViewNode) => d.id)
                .strength((d: ViewLink) => Math.min(0.2, d.score))
                .distance((d: ViewLink) => 20 + (1 - d.score) * 60),
        )
        .force("charge", d3.forceManyBody().strength(-30))
        .force(
            "center",
            d3.forceCenter(state.dimensions.width / 2, state.dimensions.height / 2),
        );
}

export function draw(state: CoreState, ctx: CanvasRenderingContext2D | null) {
    if (!ctx) return;
    const { nodes, links, transform, hoveredNode, dimensions } = state;
    const t = transform;
    const styles = getComputedStyle(document.documentElement);
    const edgeBase = styles.getPropertyValue("--edge").trim() || "rgba(100,116,139,0.22)";
    const textColor = styles.getPropertyValue("--text").trim() || "#0f172a";

    ctx.save();
    ctx.clearRect(0, 0, dimensions.width, dimensions.height);
    ctx.translate(t.x, t.y);
    ctx.scale(t.k, t.k);

    links.forEach(l => {
        const s = typeof l.source === "string" ? nodes.find(n => n.id === l.source) : l.source;
        const tg = typeof l.target === "string" ? nodes.find(n => n.id === l.target) : l.target;
        if (!s || !tg || s.x == null || s.y == null || tg.x == null || tg.y == null) return;

        ctx.strokeStyle = edgeBase.replace(/[\d.]+\)$/g, `${0.1 + l.score * 0.8})`);
        ctx.lineWidth = 0.5 + l.score * 2;
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(tg.x, tg.y);
        ctx.stroke();
    });

    nodes.forEach(n => {
        if (n.x == null || n.y == null) return;
        const radius = getNodeRadius(n);
        ctx.beginPath();
        ctx.arc(n.x, n.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = n.color;
        ctx.fill();

        if (n.type === "book") {
            ctx.fillStyle = textColor;
            ctx.font = "12px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(String(n.chapterCount ?? 0), n.x, n.y);
        }
    });

    if (hoveredNode?.x != null && hoveredNode.y != null) {
        ctx.beginPath();
        ctx.arc(
            hoveredNode.x,
            hoveredNode.y,
            getNodeRadius(hoveredNode) + 4,
            0,
            Math.PI * 2,
        );
        ctx.strokeStyle = textColor;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    ctx.restore();
}
